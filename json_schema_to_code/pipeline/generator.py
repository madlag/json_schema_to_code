"""
Pipeline generator that orchestrates all phases.

This is the main entry point for the AST-based code generation.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any

from .. import __version__
from ..cli_utils import reconstruct_command_line
from .analyzer import SchemaAnalyzer
from .ast_backends import AstBackend, CSharpAstBackend, PythonAstBackend
from .config import CodeGeneratorConfig, OutputMode
from .formatters import RuffFormatter
from .merger import AtomicWriter, CodeMergeError, PythonAstMerger
from .schema_ast import SchemaParser


class PipelineGenerator:
    """
    Pipeline code generator using AST-based backends.

    Orchestrates the phases:
    1. Parse JSON Schema to Schema AST
    2. Analyze AST and build IR
    3. Generate language-native AST from IR
    4. Serialize AST to source code
    5. (Optional) Format with ruff (Python only) - applied once at the end in generate_to_file()
    """

    def __init__(
        self,
        class_name: str,
        schema: dict[str, Any],
        config: CodeGeneratorConfig,
        language: str,
    ):
        """
        Initialize the generator.

        Args:
            class_name: Name for the root class
            schema: The JSON Schema dictionary
            config: Code generation configuration
            language: Target language ("python" or "cs")
        """
        self.class_name = class_name
        self.schema = schema
        self.config = config
        self.language = language

        # Initialize components
        self.parser = SchemaParser()
        self.analyzer = SchemaAnalyzer(language, config)
        self.backend = self._create_backend()
        self.formatter = RuffFormatter() if language == "python" else None

    def _create_backend(self) -> AstBackend:
        """Create the appropriate AST backend for the language."""
        if self.language == "python":
            return PythonAstBackend(self.config)
        elif self.language == "cs":
            return CSharpAstBackend(self.config)
        else:
            raise ValueError(f"Unsupported language: {self.language}")

    def generate(self) -> str:
        """
        Generate code using the pipeline.

        Returns:
            Generated code as a string
        """
        # Phase 1: Parse schema to AST
        ast = self.parser.parse(self.schema, self.class_name)

        # Phase 2: Analyze AST and build IR
        ir = self.analyzer.analyze(ast)

        # Set generation comment
        ir.generation_comment = self._generate_comment()

        # Phase 3 & 4: Generate code using AST backend
        code = self.backend.generate(ir)

        return code

    def _generate_comment(self) -> str:
        """Generate the file header comment."""
        if not self.config.add_generation_comment:
            return ""

        comment_prefix = "#" if self.language == "python" else "//"

        try:
            from ..json_schema_to_code import json_schema_to_code as click_command

            command_line = reconstruct_command_line(click_command)
        except (ImportError, AttributeError, RuntimeError):
            command_line = "json_schema_to_code"

        return f"{comment_prefix} Generated by json_schema_to_code v{__version__} : {command_line}"

    def generate_to_file(self, output_path: Path) -> None:
        """
        Generate code and write to file with merge support.

        Handles output modes:
        - ERROR_IF_EXISTS: Raises FileExistsError if output file exists
        - FORCE: Overwrites existing file without merging
        - MERGE: Merges custom code from existing file

        Uses atomic writes to prevent data corruption from interrupted operations.

        Args:
            output_path: Path to write the generated code

        Raises:
            FileExistsError: If file exists and mode is ERROR_IF_EXISTS
            CodeMergeError: If merge fails or would lose custom code
        """
        # Generate the code
        generated_code = self.generate()

        # Get output configuration
        output_config = self.config.output
        mode = output_config.mode

        # Determine final code based on mode
        if mode == OutputMode.ERROR_IF_EXISTS:
            if output_path.exists():
                raise FileExistsError(f"Output file already exists: {output_path}")
            final_code = generated_code

        elif mode == OutputMode.FORCE:
            final_code = generated_code

        elif mode == OutputMode.MERGE:
            if output_path.exists():
                existing_code = output_path.read_text(encoding="utf-8")
                merger = self._create_merger()
                try:
                    final_code = merger.merge_files(generated_code, existing_code, output_config.merge_strategy)
                except CodeMergeError:
                    raise
                except Exception as e:
                    raise CodeMergeError(f"Failed to merge code: {e}") from e
            else:
                final_code = generated_code
        else:
            final_code = generated_code

        # Format the final code (Python only)
        if self.formatter and self.config.formatter.enabled:
            if self.formatter.is_available():
                final_code = self.formatter.format(final_code, self.config.formatter)

        # Write to file
        writer = AtomicWriter()
        writer.write(
            output_path,
            final_code,
            self._get_language_for_writer(),
            validate=output_config.validate_before_write,
        )

    def _get_language_for_writer(self) -> str:
        """Get the language string for the atomic writer."""
        return "python" if self.language == "python" else "cs"

    def _create_merger(self):
        """Create the appropriate merger for the language."""
        if self.language == "python":
            return PythonAstMerger()
        elif self.language == "cs":
            # Import here to avoid dependency issues if tree-sitter not installed
            from .merger import CSharpAstMerger

            return CSharpAstMerger()
        else:
            raise ValueError(f"No merger available for language: {self.language}")
