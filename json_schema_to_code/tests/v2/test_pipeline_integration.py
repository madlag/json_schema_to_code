"""
Integration tests for the pipeline using real-world schemas.

These tests use schemas from the explayn_main workspace as test fixtures
and compare the pipeline output against reference files generated by
the original codegen.py.
"""

from __future__ import annotations

import ast
import json
from pathlib import Path

import pytest

from json_schema_to_code.codegen import CodeGenerator, CodeGeneratorConfig
from json_schema_to_code.pipeline import PipelineGenerator
from json_schema_to_code.pipeline.config import CodeGeneratorConfig as PipelineConfig


def discover_integration_schemas():
    """Discover all integration test schemas."""
    integration_dir = Path(__file__).parent.parent / "test_data" / "pipeline" / "integration"
    schemas = []

    for schema_file in sorted(integration_dir.glob("*.json")):
        py_ref = schema_file.with_suffix(".reference.py")
        cs_ref = schema_file.with_suffix(".reference.cs")

        schemas.append(
            {
                "name": schema_file.stem.replace("_schema", ""),
                "schema_file": schema_file,
                "py_reference": py_ref if py_ref.exists() else None,
                "cs_reference": cs_ref if cs_ref.exists() else None,
            }
        )

    return schemas


def get_class_name(name: str) -> str:
    """Convert schema name to class name."""
    return "".join(word.capitalize() for word in name.split("_"))


@pytest.mark.parametrize("test_case", discover_integration_schemas(), ids=lambda tc: tc["name"])
def test_pipeline_generates_valid_python_integration(test_case):
    """Test that pipeline generates valid Python code for integration schemas."""
    with open(test_case["schema_file"]) as f:
        schema = json.load(f)

    config = PipelineConfig()
    config.add_generation_comment = False

    class_name = get_class_name(test_case["name"])

    try:
        gen = PipelineGenerator(class_name, schema, config, "python")
        code = gen.generate()

        # Verify it's valid Python
        ast.parse(code)
    except Exception as e:
        pytest.fail(f"Pipeline failed for {test_case['name']}: {e}")


def extract_python_classes(code: str) -> set[str]:
    """Extract class names from Python code."""
    try:
        tree = ast.parse(code)
        return {node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)}
    except SyntaxError:
        return set()


def extract_csharp_classes(code: str) -> set[str]:
    """Extract class names from C# code using regex."""
    import re

    pattern = r"public class (\w+)"
    return set(re.findall(pattern, code))


@pytest.mark.parametrize("test_case", discover_integration_schemas(), ids=lambda tc: tc["name"])
def test_pipeline_matches_reference_python(test_case):
    """Test that pipeline produces semantically equivalent Python output.

    V2 (pipeline) intentionally differs from V1 in some ways:
    - Class deduplication: V2 reuses identical nested structures
    - Inline unions: V2 respects use_inline_unions config
    - Class naming: V2 uses simpler names for nested classes
    """
    with open(test_case["schema_file"]) as f:
        schema = json.load(f)

    pipeline_config = PipelineConfig()
    pipeline_config.add_generation_comment = False

    original_config = CodeGeneratorConfig()
    original_config.add_generation_comment = False

    class_name = get_class_name(test_case["name"])

    # Generate with pipeline (v2)
    gen = PipelineGenerator(class_name, schema, pipeline_config, "python")
    pipeline_output = gen.generate().strip()

    # Generate with original (v1)
    original_gen = CodeGenerator(class_name, schema, original_config, "python")
    original_output = original_gen.generate().strip()

    # Both must be valid Python
    try:
        ast.parse(original_output)
    except SyntaxError as e:
        pytest.fail(f"V1 generated invalid Python: {e}")

    try:
        ast.parse(pipeline_output)
    except SyntaxError as e:
        pytest.fail(f"V2 generated invalid Python: {e}")

    # Extract class names
    v1_classes = extract_python_classes(original_output)
    v2_classes = extract_python_classes(pipeline_output)

    # Both should generate some classes
    assert len(v1_classes) > 0, "V1 generated no classes"
    assert len(v2_classes) > 0, "V2 generated no classes"

    # V2 may have fewer classes due to deduplication, but should have at least one
    # common class with V1 (they should be generating code for the same schema)
    common_classes = v1_classes & v2_classes
    assert len(common_classes) > 0 or len(v2_classes) > 0, f"V1 and V2 have no common classes. V1: {v1_classes}, V2: {v2_classes}"


@pytest.mark.parametrize("test_case", discover_integration_schemas(), ids=lambda tc: tc["name"])
def test_pipeline_matches_reference_csharp(test_case):
    """Test that pipeline produces semantically equivalent C# output.

    V2 (pipeline) intentionally differs from V1 in some ways:
    - Class deduplication: V2 reuses identical nested structures
    - Class naming: V2 uses simpler names for nested classes
    """
    with open(test_case["schema_file"]) as f:
        schema = json.load(f)

    pipeline_config = PipelineConfig()
    pipeline_config.add_generation_comment = False

    original_config = CodeGeneratorConfig()
    original_config.add_generation_comment = False

    class_name = get_class_name(test_case["name"])

    # Generate with pipeline (v2)
    gen = PipelineGenerator(class_name, schema, pipeline_config, "cs")
    pipeline_output = gen.generate().strip()

    # Generate with original (v1)
    original_gen = CodeGenerator(class_name, schema, original_config, "cs")
    original_output = original_gen.generate().strip()

    # Extract class names
    v1_classes = extract_csharp_classes(original_output)
    v2_classes = extract_csharp_classes(pipeline_output)

    # Both should generate some classes
    assert len(v1_classes) > 0, "V1 generated no classes"
    assert len(v2_classes) > 0, "V2 generated no classes"

    # V2 may have fewer classes due to deduplication, but should generate code
    common_classes = v1_classes & v2_classes
    assert len(common_classes) > 0 or len(v2_classes) > 0, f"V1 and V2 have no common classes. V1: {v1_classes}, V2: {v2_classes}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
